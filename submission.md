# Start Here

`Name`: Michael Norris  
`NetID`: mbn0208

For each problem below, you will,

1. Fill in the the flag
2. List the steps necessary to exploit the binary. *(May be a single line.)*
3. Provide a patch that fixes the exploit. *(Generated using `make diff`.)*
4. An explanation of what the vulnerability was and how the patch fixes it. *(Keep this explanation short and to the point.)*

---

## problem1

### Flag
flag{366-iNt3G3r5iGNc0nV3r5i0N}

### Exploit Steps
1. Run `./problem1`
2. Press 1 for a Withdrawal
3. Enter in `-1000000` as quantity

### Patch
```diff
--- .originals/problem1.c	2024-03-03 03:36:58.739761800 +0000
+++ problem1.c	2024-03-03 03:59:31.132149500 +0000
@@ -37,10 +37,17 @@
 
 // Handle a large withdraw
 void large_withdraw(struct user_account *u) {
-  unsigned int withdrawal;
+  int withdrawal;//make this signed, we don't want a negative withdrawal
 
   printf("How much would you like to withdraw?\n> ");
-  scanf("%u", &withdrawal);
+  scanf("%d", &withdrawal);
+  //check that the value entered is positive as well
+  if (withdrawal <= 0)
+  {
+    printf("Sorry, you must withdrawal a value greater than 0!\n");
+    return;
+  }
+
   withdrawal += 50;
 
   // Ensure the user has enough money to complete the transaction
```

### Explanation
The vulnerability is in the function `large_withdrawal`. User input was read as an `unsigned int`, yet when it was passed to the 
`update_account_balance` function it is converted back to an int, retaining the original value input by the user. This allows the user to input negative numbers and thus actually add money to their account balance, meaning they can trigger the functionality of `VIP`. This is patched by taking in an signed int to start and checking for negative input. If negative, the user is prompted to try again.

---

## problem2

### Flag
flag{366-bUFF3r0v3RF10w_r3turn}

### Exploit Steps
1. Run `objdump -d problem2` in order to find the address of the `backdoor` function
2. run the command `./problem2 $(python2 -c "print '00000000000000000000000000000000000000000000\x80\x92\x04\x08'")`

### Patch
```diff
--- .originals/problem2.c	2024-03-03 03:36:58.682302800 +0000
+++ problem2.c	2024-03-03 04:28:24.833653800 +0000
@@ -10,7 +10,7 @@
   char out[32];
 
   memset(out, 0, sizeof(out));
-  strcpy(out, input);
+  strncpy(out, input, 32);
 
   // Copy the user's input and print it out.
   printf("user:   %s\n", input);
```

### Explanation
The vulnerability is in the `strcpy` call in parrot. The buffer `out` is only allocated 32 bytes, but `strcpy` will read in bytes until it encounters a null terminator, even beyond the buffer into unallocated space. By overfilling this buffer, we are able to place bits into memory by adding input after 32 bits, in this case replacing the return address to `main` with the address of `backdoor`, calling backdoor and thus the flag. I fixed this by swapping `strcpy` with `strncpy` which stops reading input after a specified number of characters (in this case the buffer size).

---

## problem3

### Flag
flag{366-BufFeR0v3rf10W_C4n4ry}

### Exploit Steps
1. Enter the command `./problem3 00000000000000001111111111111111`

### Patch
```diff
--- .originals/problem3.c	2024-03-03 03:36:58.866855900 +0000
+++ problem3.c	2024-03-03 04:44:53.020021300 +0000
@@ -16,7 +16,7 @@
 
   // Check that the passwords match. We're using my super special comparison function that
   // shifts password characters over by 1... throws off the hackers!
-  strcpy(passwordBuffer, input);
+  strncpy(passwordBuffer, input, 16);
 
   for (size_t i = 0; i < sizeof(passwordBuffer); i++) {
     passwordBuffer[i]++;
```

### Explanation
The vulnerability is similar to problem2 in that it involves a buffer overflow. In this case the compiler stores `passwordBuffer` and `secret` right next to each other, so if we overflow `passwordBuffer` we can write our own data into `secret`. Because the inputted password is incremented by 1 and then compared to the password, we simply need to input 16 zeroes and then 16 1s to make the passwords match. This is patched by swapping `strcpy` for `strncpy` and capping input read to 16 characters.

---

## problem4

### Flag
FLAG_GOES_HERE

### Exploit Steps
1. List your steps here

### Patch
```diff
+ Contents of ./diff/problem4.diff goes here
```

### Explanation
In your own words, write a couple sentences about why this code is vulnerable and how you fixed this vulnerability. *(Keep to 200 words or less; preferably much less.)*

---

## problem5

### Flag
FLAG_GOES_HERE

### Exploit Steps
1. List your steps here

### Patch
```diff
+ Contents of ./diff/problem5.diff goes here
```

### Explanation
In your own words, write a couple sentences about why this code is vulnerable and how you fixed this vulnerability. *(Keep to 200 words or less; preferably much less.)*

---

## problem6

### Flag
FLAG_GOES_HERE

### Exploit Steps
1. List your steps here

### Patch
```diff
+ Contents of ./diff/problem6.diff goes here
```

### Explanation
In your own words, write a couple sentences about why this code is vulnerable and how you fixed this vulnerability. *(Keep to 200 words or less; preferably much less.)*

---

## problem7

### Flag
FLAG_GOES_HERE

### Exploit Steps
1. List your steps here

### Patch
```diff
+ Contents of ./diff/problem7.diff goes here
```

### Explanation
In your own words, write a couple sentences about why this code is vulnerable and how you fixed this vulnerability. *(Keep to 200 words or less; preferably much less.)*

---
