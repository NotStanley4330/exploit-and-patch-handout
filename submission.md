# Start Here

`Name`: Michael Norris  
`NetID`: mbn0208

For each problem below, you will,

1. Fill in the the flag
2. List the steps necessary to exploit the binary. *(May be a single line.)*
3. Provide a patch that fixes the exploit. *(Generated using `make diff`.)*
4. An explanation of what the vulnerability was and how the patch fixes it. *(Keep this explanation short and to the point.)*

---

## problem1

### Flag
flag{366-iNt3G3r5iGNc0nV3r5i0N}

### Exploit Steps
1. Run `./problem1`
2. Press 1 for a Withdrawal
3. Enter in `-1000000` as quantity

### Patch
```diff
--- .originals/problem1.c	2024-03-03 03:36:58.739761800 +0000
+++ problem1.c	2024-03-03 03:59:31.132149500 +0000
@@ -37,10 +37,17 @@
 
 // Handle a large withdraw
 void large_withdraw(struct user_account *u) {
-  unsigned int withdrawal;
+  int withdrawal;//make this signed, we don't want a negative withdrawal
 
   printf("How much would you like to withdraw?\n> ");
-  scanf("%u", &withdrawal);
+  scanf("%d", &withdrawal);
+  //check that the value entered is positive as well
+  if (withdrawal <= 0)
+  {
+    printf("Sorry, you must withdrawal a value greater than 0!\n");
+    return;
+  }
+
   withdrawal += 50;
 
   // Ensure the user has enough money to complete the transaction
```

### Explanation
The vulnerability is in the function `large_withdrawal`. User input was read as an `unsigned int`, yet when it was passed to the 
`update_account_balance` function it is converted back to an int, retaining the original value input by the user. This allows the user to input negative numbers and thus actually add money to their account balance, meaning they can trigger the functionality of `VIP`. This is patched by taking in an signed int to start and checking for negative input. If negative, the user is prompted to try again.

---

## problem2

### Flag
flag{366-bUFF3r0v3RF10w_r3turn}

### Exploit Steps
1. Run `objdump -d problem2` in order to find the address of the `backdoor` function
2. run the command `./problem2 $(python2 -c "print '00000000000000000000000000000000000000000000\x80\x92\x04\x08'")`

### Patch
```diff
--- .originals/problem2.c	2024-03-03 03:36:58.682302800 +0000
+++ problem2.c	2024-03-03 04:28:24.833653800 +0000
@@ -10,7 +10,7 @@
   char out[32];
 
   memset(out, 0, sizeof(out));
-  strcpy(out, input);
+  strncpy(out, input, 32);
 
   // Copy the user's input and print it out.
   printf("user:   %s\n", input);
```

### Explanation
The vulnerability is in the `strcpy` call in parrot. The buffer `out` is only allocated 32 bytes, but `strcpy` will read in bytes until it encounters a null terminator, even beyond the buffer into unallocated space. By overfilling this buffer, we are able to place bits into memory by adding input after 32 bits, in this case replacing the return address to `main` with the address of `backdoor`, calling backdoor and thus the flag. I fixed this by swapping `strcpy` with `strncpy` which stops reading input after a specified number of characters (in this case the buffer size).

---

## problem3

### Flag
flag{366-BufFeR0v3rf10W_C4n4ry}

### Exploit Steps
1. Enter the command `./problem3 00000000000000001111111111111111`

### Patch
```diff
--- .originals/problem3.c	2024-03-03 03:36:58.866855900 +0000
+++ problem3.c	2024-03-03 04:44:53.020021300 +0000
@@ -16,7 +16,7 @@
 
   // Check that the passwords match. We're using my super special comparison function that
   // shifts password characters over by 1... throws off the hackers!
-  strcpy(passwordBuffer, input);
+  strncpy(passwordBuffer, input, 16);
 
   for (size_t i = 0; i < sizeof(passwordBuffer); i++) {
     passwordBuffer[i]++;
```

### Explanation
The vulnerability is similar to problem2 in that it involves a buffer overflow. In this case the compiler stores `passwordBuffer` and `secret` right next to each other, so if we overflow `passwordBuffer` we can write our own data into `secret`. Because the inputted password is incremented by 1 and then compared to the password, we simply need to input 16 zeroes and then 16 1s to make the passwords match. This is patched by swapping `strcpy` for `strncpy` and capping input read to 16 characters.

---

## problem4

### Flag
flag{366-iNt3g3r0v3rF10w}

### Exploit Steps
1. run `./problem4`
2. Enter value `2147483396`
3. Enter value `2`

### Patch
```diff
--- .originals/problem4.c	2024-03-03 03:36:58.769884600 +0000
+++ problem4.c	2024-03-03 05:04:40.070931300 +0000
@@ -4,6 +4,8 @@
   printf("The flag goes here");
 }
 
+int calculationOverflow(int, int);
+
 // Do not change this value.
 static const int reset_key = -504;
 
@@ -31,6 +33,12 @@
     return -1;
   }
 
+  if (calculationOverflow(value, factor)) // calculationOverflow should return 1 if the expression has a negative result
+  {
+    printf("Invalid input. Multiplication overflows to negative value!\n");
+    return -1;
+  }
+
   result = value * factor;
 
   if (result == reset_key) {
@@ -40,4 +48,17 @@
   } else {
     printf("Product: %d\n", result);
   }
+
+}
+
+int calculationOverflow(int valA, int valB)
+{
+  if (valA * valB < 0)
+  {
+    return 1;
+  }
+  else
+  {
+    return 0;
+  }
 }
```

### Explanation
The vulnerability here is that if you multiply 2 number together and the result is larger than the integer limit, it will wrap around into negative values. We want to wrap around this result to equal the secret key, so we take the 32 bit integer limit and subtract half of the absolute value fo the rest key to get the value we need to wrap around by multiplying (`2,147,483,647-(504/2)`). Then add one because 2s complement signed integers have one more possible value on the positive side then negative. Multiplying this by 2 gives the secret key, and the patch is to simply check if the result of the multiplication is negative and return -1 if it is.

---

## problem5

### Flag
flag{366-r5C3c0nd170n}

### Exploit Steps
1. run `problem5-script.sh`

### problem5-script.sh

```
#! /bin/bash

./problem5 &
CHILD_PID=$!
FILENAME=/tmp/$CHILD_PID
sleep 0.04
touch $FILENAME
```

### Patch
```diff
--- .originals/problem5.c	2024-03-03 03:36:58.712023900 +0000
+++ problem5.c	2024-03-03 05:20:39.691211800 +0000
@@ -15,7 +15,7 @@
     printf("Hey, you shouldn't have access to my file... What are you trying to pull? Go away!\n");
   } else {
     // I'm tired. Checking access is hard work... I need some sleep. 0.1 seconds should do it.
-    usleep(100000);
+    //usleep(100000);
 
     // Ok, let's open this file and write the flag to it.
     // Haha... just kidding, the user doesn't have access to the file, so this call will fail.

```

### Explanation
This vulnerability is a race condition. If you are to create the allocated file during the 0.1 seconds of sleep, the file will not be null when the sleep finishes and you will be able to trigger the flag. By having a script run that waits .04 seconds after running the program I can create the file in that sleep. This is fixed simply by removing the sleep statement. This means that there is almost zero chance of exploiting the race condition because the file is opened right after it is allocated.

---

## problem6

### Flag
flag{366-1n73g3RUnd3rfl0W}

### Exploit Steps
1. run ```python3 gen_answer_list.py``` to create a string containing all possible passwords to be guessed.
2. run ```./problem6 < answer_list.txt

### Patch
```diff
--- .originals/problem6.c	2024-03-03 03:36:58.650145000 +0000
+++ problem6.c	2024-03-28 01:46:57.892162500 +0000
@@ -13,7 +13,7 @@
   memset(password, (char)0, sizeof(password));
 
   char input[4];
-  unsigned int remainingGuesses;
+  int remainingGuesses;
 
   // Generate a random string of 3 lowercase letters
   srand((unsigned int)time(NULL));
@@ -42,9 +42,8 @@
         printf("Incorrect guess. ");
       }
     } else {
-      printf("You've run out of guesses! Please quit by pressing 'q': ");
-      scanf("%1s", input);
-      if (strstr(input, "q")) {
+      printf("You've run out of guesses! Please quit by pressing any key': ");
+      if (scanf("%1s", input)) {
         break;
       }
     }
```

### Explanation
The vulnerability here is an integer underflow. The ```remainingGuesses``` variables in an unsigned int which only stores positive numbers, however since we continue to decrement past 0 it rolls around and evaluate input when q is not hit. I exploited this by creating a text file containing all possible 3 letter strings, and because a key press was polled to check for quitting I included 19 ```0``` characters to align guesses to the start of words. I fixed this vulnerability by first changing the unsigned int to a signed one so it would not underflow, and secondly changing the input evaluation after running out of guesses to quit with any input, not just the letter q.

---

## problem7

### Flag
flag{366-Rac3c0ndi7i0N_2}

### Exploit Steps
1. run ```./problem7```
2. Hit ```2``` then type ```1000``` to deposit 1000 dollars
3. Hit ```3``` to finalize the deposit
4. Hit ```1``` then type ```1500``` to create a withdrawal of 1500 dollars
5. Repeat step 4 to create another withdrawal of 1500 dollars
6. Hit ```3``` to process these withdrawals
7. Hit ```5``` to exit and see the flag
8. Repeat these steps if the race condition did not hit

### Patch
```diff
--- .originals/problem7.c	2024-03-03 03:36:58.831653400 +0000
+++ problem7.c	2024-03-28 02:04:34.292906800 +0000
@@ -9,6 +9,8 @@
 
 int accountBalance = 1000;
 
+pthread_mutex_t threadLock;
+
 void flag() {
   printf("The flag goes here");
 }
@@ -17,9 +19,13 @@
 void *withdraw(void *arg) {
   unsigned short amount = *(unsigned short *)arg;
 
+  //lock this sucker down
+  pthread_mutex_lock(&threadLock);
   // Ensure the user has enough money to complete this transaction
   if (amount > accountBalance) {
     printf("Insufficient funds for withdrawal of $%hu\n", amount);
+    //unlock it
+    pthread_mutex_unlock(&threadLock);
     return NULL;
   }
 
@@ -29,16 +35,22 @@
   for (unsigned short i = 0; i < amount; i++) {
     --accountBalance;
   }
+  //unlock it
+  pthread_mutex_unlock(&threadLock);
   return NULL;
 }
 
 // Deposit money into the user's account
 void *deposit(void *arg) {
   unsigned short amount = *(unsigned short *)arg;
+  //lock it
+  pthread_mutex_lock(&threadLock);
 
   // Ensure that the deposit won't overflow the balance.
   if ((amount + accountBalance) > MAX_BALANCE) {
     printf("Accounts can at most have $%d. This deposit would put you over that limit!\n", MAX_BALANCE);
+    //unlock it now that access is done
+    pthread_mutex_unlock(&threadLock);
     return NULL;
   }
 
@@ -48,6 +60,7 @@
   for (unsigned short i = 0; i < amount; i++) {
     ++accountBalance;
   }
+  pthread_mutex_unlock(&threadLock);
   return NULL;
 }
 

```

### Explanation
The vulnerability is a TOCTU (time of check to time of use) race condition. Because we spawn multiple threads at a similar time to do withdrawals and both check the amount of money in the account before making withdrawals, it is possible that a withdrawal is approved that is more than the amount of money in the account if both threads check the balance before any changes are made. One way to fix this would be to process all transactions immediately after they are entered to not allow multiple transactions. However, I opted to keep the general framework and create a mutex to lock access to the balance until changes have been made. This way one thread will have to complete before the other one can check the balance and no over balance transactions will be allowed.

---
